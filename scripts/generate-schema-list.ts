#!/usr/bin/env bun

import {
  existsSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  writeFileSync,
} from "fs";
import { join, resolve } from "path";

/**
 * Generates a type-safe list of all schemas in the application
 * Scans all DTO files and extracts schema names for autocomplete
 */

const projectRoot = resolve(import.meta.dir, "..");
const srcDir = join(projectRoot, "src");
const outputDir = join(projectRoot, "src", "_generated");
const outputFile = join(outputDir, "schemas.ts");

/**
 * Recursively scans directories for DTO files
 */
function findDtoFiles(dir: string, files: string[] = []): string[] {
  if (!existsSync(dir)) {
    return files;
  }

  try {
    const items = readdirSync(dir, { withFileTypes: true });

    for (const item of items) {
      const fullPath = join(dir, item.name);

      if (item.isDirectory() && !item.name.startsWith(".")) {
        // Recursively scan subdirectories
        findDtoFiles(fullPath, files);
      } else if (item.name.endsWith(".dto.ts")) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error);
  }

  return files;
}

/**
 * Extracts schema names and file info from a DTO file
 */
function extractSchemaInfo(filePath: string): Array<{
  name: string;
  filePath: string;
  relativePath: string;
}> {
  try {
    const content = readFileSync(filePath, "utf-8");
    const schemaInfos: Array<{
      name: string;
      filePath: string;
      relativePath: string;
    }> = [];

    // Match: const schemaName = ... (must end with "Schema")
    const matches = content.matchAll(/const\s+(\w+Schema)\s*=/g);

    // Convert absolute path to relative import path
    const relativePath = filePath
      .replace(projectRoot + "/src/", "@/")
      .replace(".ts", "");

    for (const match of matches) {
      schemaInfos.push({
        name: match[1],
        filePath,
        relativePath,
      });
    }

    return schemaInfos;
  } catch (error) {
    console.error(`Error reading file ${filePath}:`, error);
    return [];
  }
}

/**
 * Generates the schema list TypeScript file
 */
export function generateSchemaList() {
  console.log("üîç Scanning for schemas in DTO files...");

  // Find all DTO files
  const dtoFiles = findDtoFiles(srcDir);
  console.log(`   Found ${dtoFiles.length} DTO files`);

  // Extract all schema info
  const allSchemaInfos: Array<{
    name: string;
    filePath: string;
    relativePath: string;
  }> = [];

  for (const file of dtoFiles) {
    const schemaInfos = extractSchemaInfo(file);
    allSchemaInfos.push(...schemaInfos);
  }

  // Remove duplicates by name and sort
  const uniqueSchemas = [
    ...new Map(allSchemaInfos.map((s) => [s.name, s])).values(),
  ].sort((a, b) => a.name.localeCompare(b.name));

  console.log(`   Extracted ${uniqueSchemas.length} unique schemas`);

  // Group schemas by file for imports
  const schemasByFile = new Map<string, string[]>();
  for (const schema of uniqueSchemas) {
    if (!schemasByFile.has(schema.relativePath)) {
      schemasByFile.set(schema.relativePath, []);
    }
    schemasByFile.get(schema.relativePath)!.push(schema.name);
  }

  // Generate import statements
  const imports = Array.from(schemasByFile.entries())
    .map(
      ([path, names]) => `import type { ${names.join(", ")} } from "${path}";`
    )
    .join("\n");

  // Generate TypeScript content
  const content = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-schema-list.ts
 * Generated at: ${new Date().toISOString()}
 * 
 * This file contains type-safe lists of all Zod schemas
 * in the application. Used for SchemaRegistry autocomplete.
 */

import type { z } from "zod";

// Import all schemas for type inference
${imports}

/**
 * List of all available schemas
 */
export const AVAILABLE_SCHEMAS = [
${uniqueSchemas.map((s) => `  "${s.name}",`).join("\n")}
] as const;

/**
 * Type-safe schema identifier
 * Provides autocomplete for SchemaRegistry methods
 */
export type SchemaIdentifier = typeof AVAILABLE_SCHEMAS[number];

/**
 * Type map for all registered schemas
 * Maps schema names to their inferred TypeScript types
 */
export type SchemaTypeMap = {
${uniqueSchemas
  .map((s) => `  "${s.name}": z.infer<typeof ${s.name}>;`)
  .join("\n")}
};

/**
 * Helper type to get TypeScript type from schema name
 * Provides autocomplete and type safety
 * 
 * @example
 * type MessageRequest = SchemaRegistryType<"messageRequestSchema">;
 */
export type SchemaRegistryType<T extends SchemaIdentifier> = SchemaTypeMap[T];

/**
 * Validates if a schema identifier is valid
 */
export function isValidSchema(identifier: string): identifier is SchemaIdentifier {
  return AVAILABLE_SCHEMAS.includes(identifier as SchemaIdentifier);
}

/**
 * Validates an array of schema identifiers
 * Returns invalid identifiers
 */
export function validateSchemas(identifiers: string[]): string[] {
  return identifiers.filter((id) => !isValidSchema(id));
}
`;

  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Write the file
  writeFileSync(outputFile, content, "utf-8");
  console.log(`‚úÖ Generated schema list at: src/_generated/schemas.ts`);
  console.log(`   Total schemas: ${uniqueSchemas.length}`);
}

// Generate on script execution
generateSchemaList();
